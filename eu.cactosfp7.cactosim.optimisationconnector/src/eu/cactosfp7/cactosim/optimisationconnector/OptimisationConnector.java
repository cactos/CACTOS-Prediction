package eu.cactosfp7.cactosim.optimisationconnector;
import java.util.Collection;
import java.util.Optional;
import java.util.logging.Logger;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.osgi.framework.BundleContext;
import org.osgi.framework.InvalidSyntaxException;
import org.osgi.framework.ServiceReference;

import eu.cactosfp7.cactoopt.optimisationservice.IOptimisationAlgorithm;
import eu.cactosfp7.cactoopt.optimisationservice.autoscaling.AutoScalingOptimisationService;
import eu.cactosfp7.cactoopt.optimisationservice.autoscaling.ITimeProvider;
import eu.cactosfp7.cactoopt.optimisationservice.registry.OptimisationServiceRegistry;
import eu.cactosfp7.cactosim.optimisationtime.util.OptimisationDurationRegistry;
import eu.cactosfp7.infrastructuremodels.load.logical.LogicalLoadModel;
import eu.cactosfp7.infrastructuremodels.load.physical.PhysicalLoadModel;
import eu.cactosfp7.infrastructuremodels.logicaldc.core.LogicalDCModel;
import eu.cactosfp7.infrastructuremodels.physicaldc.core.PhysicalDCModel;
import eu.cactosfp7.optimisationplan.OptimisationPlan;
import eu.cactosfp7.optimisationplan.OptimisationPlanRepository;
import eu.cactosfp7.optimisationplan.OptimisationplanFactory;
import eu.cactosfp7.optimisationplan.OptimisationplanPackage;
import eu.cactosfp7.optimisationplan.SequentialSteps;

/**Black-box Library implementation for QVTo allowing to access the Optimizationservice of CACTOS. 
 * @author stier, hgroenda
 *
 */
public class OptimisationConnector {
	private static final Logger LOGGER = Logger.getLogger(OptimisationConnector.class.getName());
	
    private static final URI PLAN_RESOURCE = URI.createURI("platform:/resource/org.palladiosimulator.temporary/cactosmodels/plans.optimisationplan");
    
    private static final String AUTO_SCALING_ALGORITHM_NAME = "AutoScaling";
    
    private static final ITimeProvider simulationTimeProvider = new ITimeProvider() {
		
		@Override
		public long getCurrentTimeInMs() {
			// TODO get rid of implicit assumption that simulation time is measured in seconds
			return Math.round(SimulationStateLibrary.getSimulationTime() * 1000);
		}
	};

    /**Issues a call to the Optimization service with the given models.
     * @param pdcm Physical DC Model.
     * @param ldcm Logical DC Model.
     * @param plm Physical Load Model.
     * @param llm Logical Load Model.
     * @return Optimisation plan if an optimisation should be carries out, <code>null</code> otherwise. 
     */
    public OptimisationPlan optimise(final PhysicalDCModel pdcm, final LogicalDCModel ldcm, final PhysicalLoadModel plm, final LogicalLoadModel llm) {

        LOGGER.info(String.format("Optimisation algorithm called at simulation time: %1$.3f", SimulationStateLibrary.getSimulationTime()));
        
        BundleContext bundleContext = Activator.getDefault().getBundle().getBundleContext();
        ServiceReference<?> serviceReference = bundleContext.getServiceReference(OptimisationServiceRegistry.class.getName());
        OptimisationServiceRegistry registry = (OptimisationServiceRegistry) bundleContext.getService(serviceReference);
        final Resource optResource = getOrCreateResource(pdcm.eResource().getResourceSet());
        
        Long duration = System.currentTimeMillis();
        final OptimisationPlan optimisationPlan = registry.generateOptimizationPlan(pdcm, ldcm, plm, llm);
        
        // Merge with optimisation plan generated by AutoScaler
        Optional<OptimisationPlan> autoScalingPlan = getAutoScalingAlgorithm()
        		.map(algo -> {
        			algo.setTimeProvider(simulationTimeProvider);
        			return algo.generateOptimizationPlan(pdcm, ldcm, plm, llm);
        		});
        
        autoScalingPlan.map(OptimisationPlan::getOptimisationStep).ifPresent(autoStep -> {
        	SequentialSteps encapsulatingSequentialSteps = OptimisationplanFactory.eINSTANCE.createSequentialSteps();
        	Optional.ofNullable(optimisationPlan.getOptimisationStep())
        		.ifPresent(step -> encapsulatingSequentialSteps.getOptimisationSteps().add(step));
        	encapsulatingSequentialSteps.getOptimisationSteps().add(autoStep);
        	encapsulatingSequentialSteps.setOptimisationPlan(optimisationPlan);
        });
        
        duration = System.currentTimeMillis() - duration;
        OptimisationDurationRegistry notifier = OptimisationDurationRegistry.getNotifier();
        notifier.setLastDuration(duration / 1000d);
        notifier.notifyListeners();
        
        if (optimisationPlan != null) {
        	OptimisationPlanRepository repo = optResource.getContents().stream()
        		.filter(OptimisationplanPackage.eINSTANCE.getOptimisationPlanRepository()::isInstance)
        		.map(OptimisationPlanRepository.class::cast)
        		.findAny()
        		.orElseGet(() -> {
        			OptimisationPlanRepository rep = OptimisationplanFactory.eINSTANCE.createOptimisationPlanRepository();
        			optResource.getContents().add(rep);
        			return rep;
        		});
        		
            repo.getOptimisationPlans().add(optimisationPlan);
            EcoreUtil.resolveAll(optimisationPlan);
        }
        return optimisationPlan;
    }
    
    private Optional<AutoScalingOptimisationService> getAutoScalingAlgorithm() {
    	final BundleContext bundleContext = Activator.getDefault().getBundle().getBundleContext();
		String filter = "(&(objectclass=" + IOptimisationAlgorithm.class.getName() + ")(optimisationName="+ AUTO_SCALING_ALGORITHM_NAME + "))";
		Collection<ServiceReference<IOptimisationAlgorithm>> autoScalerReferences = null;
		try {
	        autoScalerReferences = bundleContext.getServiceReferences(IOptimisationAlgorithm.class, filter);
		} catch (InvalidSyntaxException e) {
		    e.printStackTrace();
		}
		
		return Optional.ofNullable(autoScalerReferences)
				.flatMap(ref -> ref.stream().findAny())
				.map(bundleContext::getService)
				.filter(AutoScalingOptimisationService.class::isInstance)
				.map(AutoScalingOptimisationService.class::cast);
    }
    
    private Resource getOrCreateResource(ResourceSet resourceSet) {
    	Resource optResource = resourceSet.getResource(PLAN_RESOURCE, false);
        if(optResource == null) {
            optResource = resourceSet.createResource(PLAN_RESOURCE);
        }
        return optResource;
    }
}
